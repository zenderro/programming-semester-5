# Добрый день, группа 312!
<style type="text/css">
div.sourceCode {
  font-size: 1.2em;
}
section.slide > pre {
  font-size: 0.8em;
}

.reveal pre {
  width: 99%;
}
.reveal pre code {
  font-size: 1.2em;
}
.yellow-box {
  background-color: #afa;
}
.sparse-matrix img {
  height: 450px;
}
.twocolumn {
  -moz-column-count: 2;
  -webkit-column-count: 2;
}
</style>

## Курс «Практикум на ЭВМ» (по численным методам)

### Осенний семестр. Методы решения СЛУ и нахождения собственных значений
Я — **Андрей Александрович Зензинов**


email: [andrey.zenzinov@gmail.com](mailto:andrey.zenzinov@gmail.com)

Материалы к занятиям: https://zenderro.github.io/programming-semester-5/

# Дистанционное обучение

В этом семестре, в отличие от предыдущих, занятия будут проходить полностью дистанционно.

Этот материал может содержать отсылки к работе в дисплейных классах, которые в настоящее время недоступны.

Все необходимые материалы и объявления будут доступны в группе ВК.

Сдача задач будет организована с использованием GitHub Classroom.

# Как получить зачёт

Зачёт состоит из двух частей: теория, практика (решение задач).

Зачёт по теории, письменный, общий (весь курс пишет одновременно). В какой именно форме будет проходить сдача теории будет известно позже.

Для допуска к зачёту нужно сдать решения 3 задач (не считая подготовительных задач). Каждая последующая задача выдаётся после сдачи предыдущей.

Схема проведения зачётов:

0. До начала зачётной недели — досрочный теоретический зачёт (для тех, кто сдал все 3 задачи заранее, примерно до середины ноября).
1. В начале зачётной недели — теоретический зачёт (для тех, кто успел сдать 3 задачи на занятиях).
2. Два практических зачёта по 1.5 часа. Те, кто не успел сдать задачи за эти два зачёта отправляются на пересдачу.
3. Во второй половине зачётной недели — второй теоретический зачёт (для тех, кто успел сдать 3 задачи за время практических зачётов).
4. Пересдача — после каникул, в феврале. Задачи принимает комиссия из нескольких преподавателей кафедры.

# Литература
Основной курс со списком вопросов к зачёту:

- К. Ю. Богачёв. **Практикум на ЭВМ. Методы решения линейных систем и нахождения собственных значений.**
  («Методы приближения функций» — в следующем семестре)

Материалы по практике:

- К. Ю. Богачёв. Основы параллельного программирования (для второй задачи и для следующего семестра).
- *Язык программирования C*: Б. Керниган, Д. Ритчи. Язык программирования C, [А.В.Столяров. Программирование: введение в профессию](http://stolyarov.info/books/programming_intro), С. Прата. «Язык программирования C. Лекции и упражнения», [Викиучебник «Язык Си в примерах»](https://ru.wikibooks.org/wiki/Язык_Си_в_примерах);
- *Отладчик GDB:* [Руководство по использованию отладчика GDB](http://rus-linux.net/nlib.php?name=/MyLDP/algol/gdb/otladka-s-gdb.html), Н.Н. Иванов «Программирование в Linux. Самоучитель» (глава 28)
- *Командная оболочка Linux:* Д. Тейнсли. Linux и Unix: программирование в Shell. Руководство разработчика.


# Как готовить задачи

Есть несколько вариантов по созданию рабочего окружения для решения задач:

- Установить Linux (проще всего Ubuntu/Kubuntu), установить туда gcc, gdb
- Для Macbook — можно работать в Mac OS X, почти всё будет близко к Linux
- Установить Linux в виртуальной машине (компьютер должен иметь >= 8 Gb памяти, можно попробовать Xubuntu с 4)
- Для Windows (до 10) — установить [Cygwin](http://cygwin.com)
- Для Windows 10 — установить [Windows Subsystem for Linux](https://docs.microsoft.com/ru-ru/windows/wsl/install-win10)

Рекомендую ознакомиться со [статьёй М.А.Кривчикова](https://vk.com/@msumathprogx05-environment) про создание окружения.

# Работа в системе
Для редактирования исходного кода в графическом режиме можно использовать:
- текстовые редакторы Kate или gedit
- Qt Creator, Visual Studio Code

[Visual Studio Code](https://code.visualstudio.com/download) бесплатна и доступна как для Windows, так и для Mac, Linux.

В терминале:
- vim (нужно прочитать хотя бы [какое-нибудь](https://ru.wikibooks.org/wiki/Vim) [руководство](http://rus-linux.net/MyLDP/BOOKS/Vim/prosto-o-vim.pdf))
- nano (наиболее простой; команды: Ctrl+X — выход, Ctrl+O — сохранение,  Ctrl+W — поиск).


# Использование терминала и командной строки
В разных системах программа для работы с терминалом может называться по-разному.

Запуск программы из текущего каталога:

`./task-19 test-1.in`

Переход между каталогами:

`cd ~/task-19`

Специальные символы:
- `~` — домашний каталог (Shift + клавиша слева от 1)
- `..` — переход на один уровень вверх

Вывод содержимого каталога: `ls`

[Шпаргалка по командам ОС и редактору vim](http://serg.tk/static/docs/1/memosheet.pdf)

# Работа с файлами
```c
#include <stdio.h>
```

```c
FILE *f;
f = fopen(fileName, mode); // открыть файл
```
  - `"r"` — чтение
  - `"w"` — запись (если файл уже существует, он будет перезаписан, т.е. его содержмое будет удалено)
  - `"a"` — добавление в конец файла

При ошибке `f == NULL`.

```
fclose(f); // закрыть файл
```
при ошибке возвращает `EOF`

# Ввод/вывод
Вывод:
```c
printf("x = %e", x); // на экран
fprintf(f, "x = %e", x); // в файл `f`
```

Чтение: `fscanf(f, " %lf ", &x);`
возвращает количество успешно считанных аргументов, `EOF` при ошибке перед первым аргументом.

Спецификаторы форматирования:

- `%c`  — `char`
- `%s` — `char*`
- `%d` — `int, long, ...`
- `%f` — вывод `double`
- `%lf` — ввод `double`
- `%e` — вывод `double`, экспоненциальная запись, лучше не использовать для `scanf`


# Операции с числами с плавающей точкой
```c
#include <math.h>
```

Сравнение: `a == b` — для чисел с плавающей точкой использовать нельзя. Вместо этого:
```
// в начале файла:
#define EPS 1e-16
// в программе: | a - b | < ε
fabs(a - b) < EPS
```

- max(a, b) ⟼ `fmax(a, b)`; min(a, b) ⟼ `fmin(a, b)` (-std=c99)
- $e^x$ ⟼ `exp(x)`; ln x ⟼ `log(x)`; $x^y$ ⟼ `pow(x, y)`
- `sin, cos, tan, asin, acos, atan, sinh, ...`

- $\sqrt{x}$ ⟼ `sqrt(x)`; $\sqrt{x^2+y^2}$ ⟼ `hypot(x, y)`
- $⌈x⌉$ ⟼ `ceil(x)`; $⌊x⌋$ ⟼ `floor(x)`
- $ x · sgn^*(y)$ ⟼ `copysign(x, y)` ($sgn^*(0) ≡ 1$)
- $x · y + z ⟼$ `fma(x, y ,z)` (округляется только результат)
- $ y = [x], z = \{ x \}  ⟼$ `z = modf(x, &y)`

http://en.cppreference.com/w/c/numeric/math

# Сборка программы
Сборка программы из нескольких файлов:

```bash
gcc -o task-19 main.c task-19.c
```

в несколько этапов:

```bash
gcc -c -o main.o main.c
gcc -c -o task-19.o task-19.c
gcc -o task-19 main.o task-19.o
```

Аргументы командной строки для компилятора:

- -O0, ..., **-O3**, -Os — уровни оптимизации; сдавать программы, скомпилированные с ключом -O3;
- **-g** — запись отладочной информации (для отладки с использованием gdb), при разработке используйте этот ключ;
- -lm — подключение библиотеки math (для компоновки, последняя команда, если выводятся ошибки о ненайденных символах _sqrt, _fmax, ...)

# Настройки компилятора

В дисплейных классах установлены специальные настройки компилятора — более строго, чем обычно, контролируется соответствие программ стандарту, кроме того, более широкий класс ошибок приводит к аварийному завершению программы. Как получить близкое поведение на своей машине:

- Добавить к командной строке флаги:
```bash
gcc -std=c99 -pedantic -Wall -Werror -Wextra -pedantic-errors \
-Wpointer-arith -Waggregate-return \
-Wstrict-prototypes -Wmissing-declarations \
-Wlong-long -Winline -Wredundant-decls \
-Wcast-align -Wfloat-equal -D__STRICT_ANSI__ \
-Wbad-function-cast
```

- Активировать исключения underflow для чисел с плавающей точкой:
```c
// В начале файла:
#include <fenv.h>
// В начале функции main:
fenableexcept(FE_DIVBYZERO | FE_INVALID
  | FE_OVERFLOW | FE_UNDERFLOW);
```

# Стиль написания

Приоритеты:

1. Корректная работа
2. Минимальная достаточная производительность
3. Понятность кода
4. Краткость кода
5. Более, чем достаточная производительность

# Стиль написания
- выделяйте функции, которые выполняют некоторое отдельное действие в предметной области (например, умножение матриц, или умножение вектора на матрицу, или разбор аргументов)
- функция не должна быть больше 200 строк, оптимально — от одного экрана до 100 строк
- если вы несколько раз повторяете в программе одни и те же 5-10 строк, их тоже имеет смысл выделить в функцию
- предельный размер одного файла — 500-1000 строк
- разделяйте тело функции на «абзацы» — группы похожих по смыслу команд, разделённые пустыми строками
- оформляйте код однородно (условные операторы, циклы, положение фигурных скобок, отступы)

# Стиль написания
Рекомендации из [Mozilla Style Guide](https://firefox-source-docs.mozilla.org/code-quality/coding-style/coding_style_cpp.html):
```c
if (...) {
  ...
} else if (...) {
} else {
}

while (...) {
}

do {
} while (...);

for (...; ...; ...) {
}
```

# Стиль написания
```c
switch (...) {
  case 1: {
    // When you need to declare a variable in a switch, put the block in braces
    int var;
    break;
  }
  case 2:
    ...
    break;
  default:
    break;
}
```


# Система контроля версий Git

Для сдачи заданий будет использоваться система контроля версий Git, а именно - система проверки заданий GitHub Classroom.

В автоматическом режиме производится проверка отсутствия ошибок при сборке, соответствия стилю, другие "быстрые" тесты. После того, как программа пройдёт все автоматические тесты, будет проводиться ручная проверка задачи.

Для работы с этой системой необходимо зарегистрироваться в GitHub.

# Система контроля версий Git

Далее необходимо сделать предварительную настройку:

1. В WSL (или в терминале Linux/macOS) указать своё имя для Git:
```bash
git config --global user.name "Имя Фамилия"
git config --global user.email "адрес@email"
```
2. Если вы ранее этого не делали, сгенерировать SSH-ключ, пароль можно оставить пустым:

```bash
ssh-keygen -b 4096 -t rsa
```

3. Добавить его в свой профиль в GitHub (нажать на аватар, Settings, SSH and GPG Keys, New SSH Key; вставить в большое поле содержимое файла ~/.ssh/id_rsa.pub).

# Тестовое задание

Тестовое задание: https://classroom.github.com/a/J_I5nEOm

В тестовом задании необходимо вывести на экран фразу `Hello world, it's ` и далее ваше имя и фамилию.

Созданный репозиторий необходимо склонировать к себе на компьютер командой `git clone <ссылка для клонирования>`.

На странице созданного репозитория есть описание требований к форматированию кода и команды для самостоятельных проверок.


# Система контроля версий Git

После внесения изменений в файл main.c необходимо их отправить в репозиторий.

Проверка изменённых файлов, убедитесь, что main.c появился в списке изменённых файлов:

`git status`

Добавление изменённых файлов в индекс для коммита:

`git add main.c`

Коммит:

`git -m "сообщение для коммита"`

Отправка изменений в репозиторий:

`git push`

Более подробно про работу с Git можно прочитать в этой [статье](https://vk.com/@msumathprogx05-git-dlya-github-classroom)


# Заключение

После успешного выполнения задания будет назначена первая зачётная задача.
